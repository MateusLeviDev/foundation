Binary search is an algorithm; its input is a sorted list of
elements (I’ll explain later why it needs to be sorted). If
an element you’re looking for is in that list, binary search
returns the position where it’s located. Otherwise, binary
search returns null.

Simple search still takes O(n) time.

• O(log n), also known as log time. Example: Binary search.
• O(n), also known as linear time. Example: Simple search.
• O(n * log n). Example: A fast sorting algorithm, 
like quicksort (coming up in chapter 4).
• O(n2). Example: A slow sorting algorithm, like selection 
sort (coming up in chapter 2).
• O(n!). Example: A really slow algorithm, like the traveling
salesperson (coming up next!).
• Algorithm speed isn’t measured in seconds, but in growth of 
the number of operations.
• Instead, we talk about how quickly the run time of an algorithm
increases as the size of the input increases.
• Run time of algorithms is expressed in Big O notation.
• O(log n) is faster than O(n), but it gets a lot faster as the 
list of items you’re searching grows.

selection sort
==============

With linked lists, your items can be anywhere in memory.
linked lists are so much better at inserts
Linked lists are great if you’re
going to read all the items one at a time: you can read one item,
follow the address to the next item, and so on. But if you’re going
to keep jumping around, linked lists are terrible.
Arrays are different. You know the address for every item in your
array. For example, suppose your array contains five items, and you
know it starts at address 00.
Lists are better if you want to insert elements into the middle.

