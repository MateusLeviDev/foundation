+---------------+
| java/rust 1.0 |
+---------------+

@author: mateus levi souza
------- xxxx xx xxx xxxxxx

DATA TYPES
==========
 - Primitive
int, float, double, short, byte, char, boolean, long

 - Non primitive
String, Array, Class, Interface, Enum, Record

 - Wrapper classes: an object ant that object is of a class called integer
 and it can contain the value
 all primitives have a corresponding wrapper class

os wrapper foram introduzidos junto do conceito das collections. Por exemplo
set, map e etc, cada grupo desses tem suas próprias características e uma das 
necessidades é que para lidar com eles precisa ser um objeto nao um primitivo. 
 - a wrapper its adds a few more things to primitive (a primitive doesn't have
 a behavior, but wrapper class yes, can do certain things)
 
ARRAYS
==========
are a data structure that holds a fixed number of elements for the same type

int[] myArray;
myArray = new int[5];

Copying
 - muitas pessoas não sabem mas podemos copiar um array
 int[] array1 = {1,2,3,6}
 int[] array2 = array1;
 isso nao funciona se você quer uma cópia desse array1
 because an array is a reference object that lives in the heap and a array
 variable is holding a address on the heap
 
 System.arraycopy(array1, 0, array2, 0, 5)

Manipulation 
sort, fill, binary sort etc

THE STATIC KEYWORD
==========

used to indicate that a member belongs to the class itself, rather than to
a class instance 
 - indicate class level rather than object level
Global. 
Why is main static?
 - if it's not static you're running it on an instance. ok, somebody has to 
 create that instance then has to be another one. at some point of time some-
 thing has to be static. the thing that's starts it all has to run without an 
 instance being created and the first thing has to create the first instance

RECORD 
==========
fields are automatically generate as private final
constructors are automatically generated to initialize all fields
automatically gets methods like equals, hashCode, toString
derived from all of the component fields

POPULAR COLLECTIONS TYOES 
==========

LIST =  you can put, for example, the same student in list multiple times. 
 - precisam ser do mesmo tipo
SET = unique values. dont have duplicates 
MAP = a key value pair. 

COLECTIONS IS A FRAMEWORK is more than a library 

core interfaces, like list, set, map. after that they have specific 
implementations for the interface ArrayList is a impl for the list
HashSet is a impl of the set

abstract implementations 

concurrence impl is useful when you are in a multi thread environment by
default are not thread safe. 

The equals contract 
reflexivity: an object should be equal to itself
 Point p1 = new Point(1, 2).
 sout(p1.equals(p1)) // true
Symmetry: se x é igual a y, y = x
Transitivity: x = y, y = z so z =x
Consistency
Non-Nullity
 - Point p1 = new Point(1, 2).
 sout(p1.equals(null)) // false

Time Complexity: number of operations as a ratio of input 
O(1) -> constant
O(n) -> linear 
O(n ^ 2) -> quadratic
O(log n) -> logarithmic - useful in binary search - split by 2

COLLECTIONS
==========
The list interface
 - used to represent an ordered collection 
 - they can be accessed by their index
 - extends Collections
é tipo um wrapper do Array

List<String> list = Arrays.asList(elements..., ...);
ou usando 
List.of(); -> útil, por causa da imutabilidade

list é a interface, ArraysList é sua implementação. literalmente 
é um dos implements 

time complexity ArraysList
Most operations (e.g., add, get, set): O(1) on average
O(n): worst case (when the array needs to be resized).
por exemplo quando temos um array de 4 elementos 
o time complexity de O(1), setando um de cada vez.
o que acontece se adicionar um quinto elemento?
podemos adicionar uma nova? mas o espaço seguinte pode
não ter espaço, estamos no heap, pode estar ocupado por
outra estância. não é garantia de ter algo 'a sua direita'
pensando, estamos no heap (all these references live on
next to the other that the space on the right might ve
taken by another instance).
a implementação simplesmente cria uma lista maior
dobra seu tamanho. double the size then copies all this 
things over e depóis descarta o antigo array
time complex é O(n) por que ele copiar tudo, é mais que O(1)

amortized time complex: pois a criação e cópia para o novo array 
exigem percorrer todos os elementos da lista. 
Criação de um novo array: Isso tem complexidade de tempo O(n), 
nde n é o número de elementos na lista, pois todos os elementos 
precisam ser copiados para o novo array. 
é importante destacar que essa eficiência de tempo O(1)O(1) 
para inserção no final ocorre apenas quando há espaço disponível
na capacidade atual da ArrayList. Se a capacidade for excedida e 
a lista precisar ser redimensionada, a complexidade de tempo para 
inserção pode se tornar O(n)O(n), como discutido anteriormente.

