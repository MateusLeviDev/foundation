@author: mateus levi souza
------- xxxx xx xxx xxxxxx



Example building my own image with a Dockerfile ===============

FROM node -> we're telling docker: in my image i wanna start pulling 
that node image

next, which files should go into the image
COPY . /app

pt-br: basicamente específica dois caminhos nesse trecho. dessa forma,
o primeiro caminho é o caminho fora do container, fora da imagem de onde
saem os arquivos que devem ser copiados into the image [nessa parte 
'exclui'], ele não conta com o dockerfile. Ou seja, esse primeiro 
caminho 'mostra' ao docker que todas as pastas e subpastas e arquivos 
devem ser copiados para o DMH.

o segundo caminho é o caminho dentro da imagem onde os arquivos devem ser
armazenados. podemos nomear com o nome que quisermos. 

- cada imagem e também para cada container criado a partir de uma imagem
possui seu próprio sistema de arquivos interno que é totalmente dff dos
arquivos da nossa máquina
- nao usar o root path do nosso docker container e nomear por ex: /app


next step we need to run npm install, for node applications, like the example

RUN npm intall

bizu:
precisamos indicar que os comandos subsequentes serão executados dentro dessa
pasta /app

by default all those commands will be executed in the working directory of
our docker container and image. and by default, that working directory is 
the root folder in that container file system.
como estou copiando para o /app tb quero que a instalação do npm seja executada 
dentro do /app. usamos

WORKDIR /app -> before COPY AND RUN

bizu:
a imagem deve ser o template para o container. a imagem não é o que será executado
o que será executado será o container baseado na respectiva imagem. ou seja, não 
é necessário que start do server seja na imagem. devemos instalar todas as 
dependências lá, ter todo o código. mas só queremos inciar um server se startarmos 
um container baseado em uma imagem 

dessa forma, ao iniciarmos vários containers em uma imagem, iniciaremos vários node 
servers

CMD ['node', 'server.js']

cmd -> a dff para o run é que agora nao será executado quando quando a imagem for 
criada mas quando um container for iniciado com base na imagem 

- um container docker está isolado de nosso ambiente local. portanto, tem sua própria
rede interna. devemos indica a expose to our local system 

EXPOSE 80.

=======================================================================================

FROM node

WORKDIR /app

COPY . /app

RUN npm install

EXPOSE 80

CMD [ "node" , "server.js" ]

=======================================================================================

docker build . 

temos essa instrução expose 80 em nosso dockerfile, mas precisamos fazer mais
é basicamente para documentação, indicando quais portas serão expostas pelo container 
precisamos indicar 

docker container start -p 3000:80 XXX

=======================================================================================
Quando falamos de **Docker estamos falando de isolamento**. Esse isolamento pode ser 
dividido em duas ideias. Primeiramente a parte do **isolamento** seria processo **lógico** 
(redes, processos, usuários, outpoint), outro ponto interessante é o **isolamento** 
referente aos **recursos** (gerenciamento de recursos, CPU, memória, IO de rede ou IO de 
bloco), uma parte mais física.

Isolamento lógico → names spaces

Isolamento de recurso → sed group (confirmar nome)

every instruction represent a layer in dockerfile
- image is read-only 
- a image is built up from mult layers
- image is locked in, unless rebuilt 

o docker armazena algumas informações em chache. portanto, o docker apenas reconstrói e 
executa novamente o que precisa ser executado -> um mecanismo muito útil 
quando uma camada muda, todas as outras são reconstruídas [all layers after the changing layer]

1ª SUMMARY
==============

com o docker, tudo gira em torno no nosso código. <code> 
image -> <code> + <environment> 
- Docker permite o isolamento de CPU, rede e etc
- pense imagem como a materialização de um sistema de arquivos

O que é uma imagem: Penso na imagem tentando correlacionar com a POO. A imagem seria como 
uma classe pai onde os filhos (containers) herdam suas características. Agora de forma mais 
técnica, ela é a materialização de um sistema de arquivos, onde tem o source code, environment
e tools. é criado a partir de um dockerfile, por exemplo:

- Uma imagem do CentOS contém um sistema operacional CentOS completo. 
- A partir de uma imagem pronta podemos ter esse reuso e personalizar o que precisamos (containers)

O que é um container: Ele é basicamente um conjunto de file systems criados a partir de uma imagem.
é melhor diversificar seu uso, usando mais de , justamente por causa desse isolamento que pode ser 
diferente para imagem criada  a partir disso, como o uso de nginx é diferente de uma imagem mysql,
por exemplo.

ou seja, Pense no container como um processo, processo esta na memória do computador. Já a imagem 
é um arquivo de modelo que contém arquivos e monta o sistema que o container terá acesso criando 
esse processo.
Um contêiner é uma instância de uma imagem. Ele é um processo que executa o código da imagem em 
um ambiente isolado. O contêiner tem seu próprio sistema de arquivos, rede e processos.

=======================================================================================

Managing images and containers

remover imagens e containers.
- criar um run usando o --rm para remover o contaiiner após stopar
- entrar no modo interativo -a -i || exec -it 
